local func = require "ste/func"
local coor = require "ste/coor"
local line = require "ste/coorline"
local arc = require "ste/coorarc"
local pipe = require "ste/pipe"
local ste = require "ste"

local dump = require "luadump"

local math = math
local pi = math.pi
local abs = math.abs
local table = table
local unpack = table.unpack
local insert = table.insert

local infi = 1e8
local lengthList = func.seq(80, 400)
local slopeList = {2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {15, 12, 10, 8, 7.5, 6, 5, 4, 3.5, 3, 2.5, 2, 1.75, 1.5, 1.25, 1, 0.9, 0.85, 0.8, 0.75, 0.7, 0.666, 0.633, 0.6, 0.566, 0.533, 0.5, 0.475, 0.45, 0.425, 0.4, 0.375, 0.35, 0.325, 0.3, 0.28, 0.26, 0.24, 0.22, 0.2, 0.18, 0.16, 0.14, 0.12, 0.1, 0.09, 0.08, 0.07, 0.06, 0.05}
local rList = pipe.new * rList * pipe.map(pipe.neg()) * pipe.rev() / infi + rList
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10}
local portailHeightList = func.seqMap({0, 30}, function(h) return h * 0.5 end)
-- local slopeList = pipe.new * ste.slopeList * pipe.map(pipe.neg()) * pipe.rev() / 0 + ste.slopeList
local wallList = {
    "ste/2/concrete_wall",
    "ste/2/brick_wall",
    "ste/2/arch_wall",
}

local fenceList = {
    "ste/2/concrete_roof_fence_front",
    "ste/2/brick_roof_fence_front",
    "ste/2/brick_roof_fence_front"
}

local function params()
    return {
        {
            key = "radiusS",
            name = _("MENU_RADIUS_SURFACE"),
            values = rList * pipe.map(function(r) return r > 15 and "∞" or tostring(math.floor(r * 1000)) end),
            uiType = "SLIDER",
            defaultIndex = (#rList - 1) / 2
        },
        {
            key = "radiusU",
            name = _("MENU_RADIUS_SURFACE"),
            values = rList * pipe.map(function(r) return r > 15 and "∞" or tostring(math.floor(r * 1000)) end),
            uiType = "SLIDER",
            defaultIndex = (#rList - 1) / 2
        },
        {
            key = "length",
            name = _("MENU_LENGTH"),
            values = func.map(lengthList, tostring),
            uiType = "SLIDER",
            defaultIndex = 69
        },
        {
            key = "portailHeight",
            name = _("MENU_PORTAIL_HEIGHT"),
            values = func.map(portailHeightList, tostring),
            uiType = "SLIDER",
            defaultIndex = 0
        },
        {
            key = "freeNodes",
            name = _("Free tracks"),
            values = {_("No"), _("Yes"), _("Not build")},
            defaultIndex = 0
        }
    }

end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    
    func.forEach(params(), function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end

local offsetGen = function(meta)
    local function gen(result, base, lastPos, fst, snd, ...)
        if (fst and snd) then
            local pos = snd.pos
            local offset = base + (fst.width + snd.width) * 0.5
            
            return gen(result + {{pos, offset}}, offset, pos, snd, ...)
        else
            return result
        end
    end
    return gen(pipe.new * {}, 0, nil, {width = 0}, unpack(meta))
end

local config = function(params)
    local height = 8.5
    local portail = portailHeightList[params.portailHeight + 1]

    local length = lengthList[params.length + 1]
    local trackSlope = (height - portail) / length
    local wallSlope = portail / length

    local radius = {
        surface = rList[params.radiusS + 1] * 1000,
        underground = rList[params.radiusU + 1] * 1000
    }
    
    local fz = {
        surface = function(initRad, finalRad)
            local ln = line.byPtPt(
                coor.xy(initRad, -height + portail),
                coor.xy(finalRad, 0)
            )
            return function(rad) return (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y end
        end,
        underground = function(initRad, finalRad)
            local ln = line.byPtPt(
                coor.xy(initRad, -height + portail),
                coor.xy(finalRad, (-height + portail) * 2)
            )
            return function(rad) return (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y end
        end,
        wall = function(initRad, finalRad)
            local ln = line.byPtPt(
                coor.xy(initRad, portail),
                coor.xy(finalRad, 0)
            )
            return function(rad) return (ln - line.byVecPt(coor.xy(0, 1), coor.xy(rad, 0))).y end
        end,
    }
    
    local fs = {
        surface = function(initRad, finalRad) return function(_) return trackSlope end end,
        underground = function(initRad, finalRad) return function(_) return -trackSlope end end,
        wall = function(initRad, finalRad) return function(_) return -wallSlope end end,
    }
    
    local arcPackers = {
        surface = ste.arcPacker(length, radius.surface, fz.surface, fs.surface),
        underground = ste.arcPacker(-length, radius.underground, fz.underground, fs.underground),
        wall = ste.arcPacker(length, radius.surface, fz.wall, fs.wall),
    }
    
    local min = {}
    local modules = {}
    
    local allPos = {}
    for slotId, m in pairs(params.modules) do
        local info = ste.slotInfo(slotId)
        if not func.contains(allPos, info.pos.x) then
            insert(allPos, info.pos.x)
            min[info.pos.x] = {
                underground = 100,
                surface = 100
            }
        end
        if info.typeId == 2 then
            if not min[info.pos.x].underground or min[info.pos.x].underground > info.pos.y then
                min[info.pos.x].underground = info.pos.y
            end
        else
            if not min[info.pos.x].surface or min[info.pos.x].surface > info.pos.y then
                min[info.pos.x].surface = info.pos.y
            end
        end
        modules[info.pos.x] = func.with(m,
            {
                metadata = func.with(m.metadata, {slotId = slotId, pos = info.pos.x})
            })
    end
    
    table.sort(allPos)
    local posMin = func.min(allPos)
    local posMax = func.max(allPos)
    
    local offsets = pipe.new
        * func.seq(posMin > 50 and 49 or (posMin - 1), posMax + 1)
        * pipe.map(function(pos)
            return modules[pos] and modules[pos].metadata or {pos = pos, width = 5}
        end)
        * offsetGen
    
    local reOffset = func.filter(offsets, function(o) return o[1] == 50 end)[1][2]
    offsets = offsets * pipe.map(function(o) return {o[1], o[2] - reOffset} end)
    
    local entityOffsets = offsets * pipe.fold(pipe.new * {}, function(r, o) return func.contains(allPos, o[1]) and r / o[2] or r end)
    
    local coords = {}
    local arcs = {}
    for i, pos in ipairs(allPos) do
        local typeId = modules[pos].metadata.slotId % 10
        if (typeId > 3) then
            arcs[pos] = {wall = arcPackers.wall(entityOffsets[i])}
            coords[pos] = {offset = entityOffsets[i]}
        else
            arcs[pos] = {
                surface = arcPackers.surface(entityOffsets[i]),
                underground = arcPackers.underground(entityOffsets[i]),
                top = arcPackers.wall(entityOffsets[i])
            }
            coords[pos] = {offset = entityOffsets[i]}
        end
    end
    
    for pos, refArc in pairs(arcs) do
        if (refArc.surface) then
            local biLatCoords, nSeg = ste.biLatCoords(5, refArc.surface)
            coords[pos].surface = {biLatCoords = biLatCoords, nSeg = nSeg, coords = ste.interlace(biLatCoords(0))}
        end

        if (refArc.wall) then
            local biLatCoords, nSeg = ste.biLatCoords(5, refArc.wall)
            coords[pos].wall = {biLatCoords = biLatCoords, nSeg = nSeg, coords = ste.interlace(biLatCoords(0))}
        end

        if (refArc.top) then
            local biLatCoords, nSeg = ste.biLatCoords(5, refArc.top)
            coords[pos].top = {biLatCoords = biLatCoords, nSeg = nSeg, coords = ste.interlace(biLatCoords(0))}
        end

        if (refArc.underground) then
            local biLatCoords, nSeg = ste.biLatCoords(5, refArc.underground)
            coords[pos].underground = {biLatCoords = biLatCoords, nSeg = nSeg, coords = ste.interlace(biLatCoords(0))}
        end
    end
    
    return {
        arcs = arcs,
        coords = coords,
        allPos = allPos,
        offsets = offsets,
        min = min,
        modules = modules
    }
end

local createTemplateFn = function(params)
    local trackNb = trackNumberList[params.trackNb + 1]
    
    local minPos = 50 - (trackNb % 2 == 1 and (trackNb - 1) / 2 or trackNb / 2)
    local maxPos = minPos + trackNb - 1
    
    local result = {}
    
    for i = 1, 99 do
        for p = minPos, maxPos do
            result[p * 1000 + i * 10 + 1] = "station/rail/ste_track_standard.module"
            result[p * 1000 + i * 10 + 2] = "station/rail/ste_track_standard.module"
        end
    end
    for i = 0, 99 do
        result[(minPos - 1) * 1000 + i * 10 + 4] = "station/rail/ste_wall.module"
        result[(maxPos + 1) * 1000 + i * 10 + 4] = "station/rail/ste_wall.module"
        result[(minPos - 2) * 1000 + i * 10 + 3] = "station/rail/ste_track_standard.module"
        result[(maxPos + 2) * 1000 + i * 10 + 3] = "station/rail/ste_track_standard.module"
    end
    return result
end

local upgradeFn = function(params)
    end

local updateFn = function(params)
    defaultParams(params)
    local config = config(params)
    
    local result = {
        edgeLists = {},
        models = pipe.new * {},
        terrainAlignmentLists = {{type = "EQUAL", faces = {}}},
        groundFaces = {},
        slots = pipe.new * {},
        config = config
    }
    
    for _, pos in ipairs(config.allPos) do
        if (config.modules[pos]) then
            if (config.modules[pos].metadata.isTrack) then
                if (ste.slotInfo(config.modules[pos].metadata.slotId).typeId == 3) then
                    for i = 0, 99 do
                        local nSeg = config.coords[pos].top.nSeg
                        local coord = i < nSeg and config.coords[pos].top.coords[nSeg - i] or config.coords[pos].top.coords[1]
                        coord = i < nSeg and coord.s:avg(coord.i) or coord.s
                        insert(result.slots, {
                            id = pos * 1000 + i * 10 + 3,
                            transf = coor.trans(coord),
                            type = "ste_track",
                            spacing = {2.5, 2.5, 0, 0}
                        })
                    end
                else
                    for i = 0, 99 do
                        local nSeg = config.coords[pos].surface.nSeg
                        local coord = i < nSeg and config.coords[pos].surface.coords[nSeg - i] or config.coords[pos].surface.coords[1]
                        coord = i < nSeg and coord.s:avg(coord.i) or coord.s
                        insert(result.slots, {
                            id = pos * 1000 + i * 10 + 1,
                            transf = coor.trans(coord),
                            type = "ste_track",
                            spacing = {2.5, 2.5, 0, 0}
                        })
                        
                            
                        local nSeg = config.coords[pos].underground.nSeg
                        local coord = i < nSeg and config.coords[pos].underground.coords[nSeg - i] or config.coords[pos].underground.coords[1]
                        coord = i < nSeg and coord.s:avg(coord.i) or coord.s
                        insert(result.slots, {
                            id = pos * 1000 + i * 10 + 2,
                            transf = coor.trans(coord),
                            type = "ste_track",
                            spacing = {2.5, 2.5, 0, 0}
                        })
                    end
                end
            else
                for i = 0, 99 do
                    local nSeg = config.coords[pos].wall.nSeg
                    local coord = i < nSeg and config.coords[pos].wall.coords[nSeg - i] or config.coords[pos].wall.coords[1]
                    coord = i < nSeg and coord.s:avg(coord.i) or coord.s
                    insert(result.slots, {
                        id = pos * 1000 + i * 10 + 4,
                        transf = coor.trans(coord),
                        type = "ste_wall",
                        spacing = {0.25, 0.25, 0, 0}
                    })
                end
            end
        else
            end
    end
    result.terminateConstructionHook = function()
        local terrainEql = {}
        local terrainGrt = {}
        for _, coords in pairs(result.config.coords) do
            if (coords.surface and coords.surface.top) then
                insert(terrainEql, func.map(func.concat(coords.surface.top.lc, func.rev(coords.surface.top.rc)), coor.vec2Tuple))
            end
            if (coords.underground and coords.underground.top) then
                insert(terrainGrt, func.map(func.concat(func.rev(coords.underground.top.lc), coords.underground.top.rc), coor.vec2Tuple))
            end
        end
        
        insert(result.terrainAlignmentLists, {type = "EQUAL", faces = terrainEql})
        insert(result.terrainAlignmentLists, {type = "GREATER", faces = terrainGrt})
    end
    return result
end


function data()
    local constructionTemplates =
        {
            {
                constructionType = "RAIL_STATION",
                type = "DYNAMIC",
                availability = {
                    yearFrom = 1863,
                    yearTo = 0
                },
                description = {
                    name = _("MENU_NAME"),
                    description = _("MENU_DESC"),
                },
                data = {
                    params = {
                        {
                            key = "trackNb",
                            name = _("MENU_TRACK_NR"),
                            values = func.map(trackNumberList, tostring),
                            uiType = "SLIDER",
                            defaultIndex = 1
                        },
                        {
                            key = "catenary",
                            name = _("MENU_TRACK_CAT"),
                            uiType = "CHECKBOX",
                            values = {"0", "1"},
                            defaultIndex = 1
                        },
                        {
                            key = "highspeed",
                            name = _("MENU_TRACK_HS"),
                            uiType = "CHECKBOX",
                            values = {"0", "1"},
                            defaultIndex = 1
                        },
                    }
                },
            }
        }
    
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Compact Tunnel entry"),
            description = _("A compact tunnel entry")
        },
        -- categories = { "ste" },
        availability = {
            yearFrom = 1860
        },
        -- buildMode = "MULTI",
        -- order = 27229,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        -- skipCollision = true,
        -- austemovable = false,
        params = params(),
        upgradeFn = upgradeFn,
        updateFn = updateFn
    }

end
